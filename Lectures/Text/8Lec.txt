
1 March - Exam0

---

Synchronization
- consistency
- operations on data require making copies
- once copied in to local state, global data can become inconsistent
- can not allow user code to lock out other code without surrendering scheduling to the user
(oh noes!)
- need hardware support - in particular - "atomic" functions that read, modify and write shared state "at once"

hardware instr:
test and set
fetch and incr
compare and swap

constructs:
mutexes (locks) - synch on data
barriers - synch on comp
condition vars - synch on events


Monitor - OO synch supervisor that allocates resources
prithee whither?
- mutual exclusion is dangerous (tm)

deadlock: ( =^( )
- can not compute at all due to interleaved dependencies:
a. mutual exclusion
b. hold and wait
c. no-preemption
d. circular wait  <-- global ordering on locking, rising/falling permission phases

livelock:
- can compute, but will never get the required resource

starvation:
- will never get the required resource

why monitors given above?:
- may have a plan of resource priority for threads
- sometimes global ordering and whatnot is not possible based on what the resources are or how the system works


Semaphores
- insensitive to identity
- insensitive to ordering
	- blocks on both ends ... on post to max value and wait on 0


---

Scheduling:
Banker's Algorithm
 need some future knowledge ... all Procs must tell you how of a resource they will need, at max

know how much of X there is to be allocated
know how much of X each proc needs, at max
make sure there is a chain of allocations that will allow:
	at least one proc to reach its max
	be run to completion
	have resources reclaimed and added to the available pool
.. for all procs


Time:
FIFO - run 'till done in dispatch order
+:
	dead easy
-:
	dead st00pid - could cause short, important procs to wait for long, unimportant procs
	(can clobber turnaround time)
	

RR - everyone gets an equal amount of runtime
+:
	fairly simple to code
	don't have to wait for proc to finish to get to run
	(good for response time)
-:
	do have to wait for all other procs to take their slices
obs:
	shortest jobs will finish first (even if they take a long time to do so in a loaded system)


To allocate resources:
first, dumbest strategy with no knowledge
next, best strategy with full knowledge of future
then .. try to approx best strategy with worst strategy with full knowledge of past	
	
SJF - shortest jobs, ftw (non-preemptive)
+:
	good response time
	middling turnaround time
	trying to be optimal
-:
	no notion of priority
	could starve out longer procs


SRTF - jobs with least remaining time go first (preemptive)
... still with the starvation risk


RR .. .again ..
... but ... can tune the quantum (!!!)
what if Q <<?
 .. the smaller the quantum, the closer to SRTF (SJF !!! :^D)
what if Q >>?
 .. the larger the quantum, the closer to FIFO
 lurking in the feathers:
 .. overhead of context switch ... so need to balance cost of switch against gain of another proc running...
 
 
 
 
 
 
 
 

 











	
	

	
	
	
	
	
	
	
	
	
	